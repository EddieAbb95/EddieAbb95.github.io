<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
  <meta name="description" content="My name is Eddie Abbondanzio and this is my personal blog for all things related to software development, architecture, design patterns, web development, and more. I also post updates on my car build threads." />
  <title>Greedy Meshing for Vertex Colored Voxels In Unity &middot; Eddie Abbondanzio</title>
  <link rel="stylesheet" href="https://eddieabbondanz.io/css/style.css" />
  <link rel="stylesheet" href="https://eddieabbondanz.io/css/font-awesome.min.css" />
  <link href='https://fonts.googleapis.com/css?family=Lato:100,300,400,600' rel='stylesheet' type='text/css'>
</head>
<body>


<header class="header" style="background-color: rgb(46, 155, 218);  ;" role="banner">


      
      <section id="branding">
        <div id="site-title"><a href="https://eddieabbondanz.io">Eddie Abbondanzio</a></div>
        <nav id="mainmenu">
          <ul>
            <li><a href="https://eddieabbondanz.io/about">About Me</a></li>
            <li><a href="http://github.com/EddieAbbondanzio" target="_blank">Github</a></li>
            <li><a href="https://twitter.com/EAbbondanzio" target="_blank">Twitter</a></li>
            <li><a href="https://edsautodetailing.com" target="_blank">Ed's Auto Detailing</a></li>
        </ul>
        </nav>
        <input type="checkbox" id="op"></input>
        <div class="lower">
          <label for="op">Menu</label>
        </div>
        <div class="overlay overlay-hugeinc">
          <label for="op"></label>
          <nav id="menu" role="navigation">
            <ul>
            <li><a href="https://eddieabbondanz.io">Home</a></li>
            <li><a href="https://eddieabbondanz.io/about">About Me</a></li>
            <li><a href="http://github.com/EddieAbbondanzio" target="_blank">Github</a></li>
            <li><a href="https://twitter.com/EAbbondanzio" target="_blank">Twitter</a></li>
            <li><a href="https://edsautodetailing.com" target="_blank">Ed's Auto Detailing</a></li>
          </ul>
          </nav>
        </div>
        <div class="clearfix"></div>
      </section>

      <div class="header-overlay">
        <div class="post-heading">
          <h1>
          Greedy Meshing for Vertex Colored Voxels In Unity
            <div class="share-icons-header">
              <a href="http://www.twitter.com/share?url=https%3a%2f%2feddieabbondanz.io%2fpost%2fvoxel%2fgreedy-mesh%2f" target="_blank">
              <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 612 612" style="enable-background:new 0 0 612 612;" xml:space="preserve">
              <g>
                <g>
                  <path d="M437.219,245.162c0-3.088-0.056-6.148-0.195-9.18c13.214-9.848,24.675-22.171,33.744-36.275
                    c-12.129,5.453-25.148,9.097-38.835,10.626c13.965-8.596,24.675-22.338,29.738-38.834c-13.075,7.928-27.54,13.603-42.924,16.552
                    c-12.323-14.021-29.904-22.95-49.35-23.284c-37.332-0.612-67.598,30.934-67.598,70.463c0,5.619,0.584,11.072,1.752,16.329
                    c-56.22-3.616-106.042-32.881-139.369-77c-5.814,10.571-9.152,22.922-9.152,36.164c0,25.037,11.934,47.291,30.071,60.421
                    c-11.099-0.5-21.503-3.866-30.627-9.375c0,0.306,0,0.612,0,0.918c0,34.996,23.312,64.316,54.245,71.159
                    c-5.675,1.613-11.656,2.448-17.804,2.421c-4.367-0.028-8.596-0.501-12.713-1.392c8.596,28.681,33.577,49.628,63.147,50.323
                    c-23.145,19.194-52.298,30.655-83.955,30.572c-5.453,0-10.849-0.361-16.135-1.029c29.933,20.53,65.456,32.491,103.65,32.491
                    C369.23,447.261,437.219,339.048,437.219,245.162z"/>
                  <path d="M612,306C612,137.004,474.995,0,306,0C137.004,0,0,137.004,0,306c0,168.995,137.004,306,306,306
                    C474.995,612,612,474.995,612,306z M27.818,306C27.818,152.36,152.36,27.818,306,27.818S584.182,152.36,584.182,306
                    S459.64,584.182,306,584.182S27.818,459.64,27.818,306z"/>
                </g>
              </svg></a>
              <a href="http://plus.google.com/share?url=https%3a%2f%2feddieabbondanz.io%2fpost%2fvoxel%2fgreedy-mesh%2f" target="_blank">
              <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 612 612" style="enable-background:new 0 0 612 612;" xml:space="preserve">
                <g>
                  <g>
                    <path d="M349.146,402.251c0-30.016-17.387-44.815-36.525-60.922l-15.662-12.185c-4.785-3.895-11.294-9.124-11.294-18.693
                      c0-9.57,6.537-15.662,12.184-21.309c18.249-14.354,36.526-29.571,36.526-61.756c0-33.076-20.892-50.462-30.878-58.724l0,0h26.956
                      L358.271,153h-89.603c-23.479,0-53.049,3.478-77.863,23.924c-18.693,16.079-27.818,38.278-27.818,58.279
                      c0,33.911,26.093,68.294,72.188,68.294c4.368,0,9.125-0.445,13.937-0.863c-2.17,5.23-4.34,9.569-4.34,16.97
                      c0,13.464,6.955,21.753,13.047,29.57c-19.556,1.308-56.109,3.478-83.065,20.001c-25.676,15.217-33.493,37.416-33.493,53.077
                      c0,32.186,30.461,62.201,93.525,62.201C309.561,484.454,349.146,443.116,349.146,402.251z M255.621,291.34
                      c-37.415,0-54.384-48.292-54.384-77.418c0-11.322,2.17-23.034,9.569-32.186c6.955-8.707,19.139-14.382,30.461-14.382
                      c36.108,0,54.802,48.738,54.802,80.033c0,7.845-0.862,21.754-10.877,31.768C278.237,286.11,266.498,291.312,255.621,291.34z
                      M256.066,466.177c-46.54,0-76.556-22.171-76.556-53.049s27.846-41.311,37.416-44.787c18.276-6.093,41.755-6.982,45.677-6.982
                      c4.34,0,6.51,0,9.987,0.445c33.076,23.479,47.402,35.218,47.402,57.416C319.992,446.176,297.821,466.177,256.066,466.177z"/>
                    <polygon points="353.068,317.768 400.164,317.768 400.164,364.836 423.699,364.836 423.699,317.768 470.768,317.768 
                      470.768,294.233 423.699,294.233 423.699,247.165 400.164,247.165 400.164,294.233 353.068,294.233     "/>
                    <path d="M612,306C612,137.004,474.995,0,306,0C137.004,0,0,137.004,0,306c0,168.995,137.004,306,306,306
                      C474.995,612,612,474.995,612,306z M27.818,306C27.818,152.36,152.36,27.818,306,27.818S584.182,152.36,584.182,306
                      S459.64,584.182,306,584.182S27.818,459.64,27.818,306z"/>
                  </g>
              </svg></a>
              <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2feddieabbondanz.io%2fpost%2fvoxel%2fgreedy-mesh%2f" target="_blank">
              <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                viewBox="0 0 612 612" style="enable-background:new 0 0 612 612;" xml:space="preserve">
              <g>
                <g>
                  <path d="M612,306C612,137.004,474.995,0,306,0C137.004,0,0,137.004,0,306c0,168.995,137.004,306,306,306
                    C474.995,612,612,474.995,612,306z M27.818,306C27.818,152.36,152.36,27.818,306,27.818S584.182,152.36,584.182,306
                    S459.64,584.182,306,584.182S27.818,459.64,27.818,306z"/>
                  <path d="M317.739,482.617V306h58.279l9.208-58.529h-67.487v-29.348c0-15.272,5.007-29.849,26.928-29.849h43.813v-58.418h-62.201
                    c-52.298,0-66.569,34.438-66.569,82.175v35.413h-35.885V306h35.885v176.617H317.739L317.739,482.617z"/>
                </g>
              </svg>
              </a>
            </div>
            
          </h1>
        </div>
    </div>
    </header>

    <div id="container">


<section id="content" role="main">
<section class="entry-meta">
  <span class="post-date">Mar 25, 2018</span>
</section></header>
<section class="entry-content">
<article>
<p><strong>TL;DR</strong> Full algorithm is at the bottom. Classes for <code>Block</code>, <code>Chunk</code>, and <code>MeshData</code> are defined below the intro.</p>

<p>This article goes over how to implement a greedy meshing algorithm for generating optimized meshes for vertex-colored voxels in Unity. The algorithm is derived from <a href="https://github.com/roboleary/GreedyMesh">Robert O&rsquo;Leary</a>, with a few alterations made.</p>

<p>The setup has been simplified, and assumes the world is only comprised of a single chunk that holds all the blocks. With a few tweaks it wouldn&rsquo;t be hard to add support for multiple chunks, but since there are several different solutions to achieve this, I&rsquo;ve left it up to the reader.</p>

<p>I prefer colored blocks over typed blocks. As such each block in my implementation holds 4 bytes of data for the color (red, green, blue, and alpha). A block is considered &ldquo;solid&rdquo; if the alpha value is maxed out.</p>

<pre><code class="language-csharp">// Block.cs
public struct Block {
    public byte R { get; }
    public byte G { get; }
    public byte B { get; }
    public byte A { get; }

    public Block(byte r, byte g, byte b, byte a = byte.MaxValue) {
        R = r;
        G = g;
        B = b;
        A = a;
    }

    public bool IsSolid() =&gt; A == byte.MaxValue;
    public Color32 GetColor() =&gt; new Color32(R, G, B, A);
}
</code></pre>

<p>Blocks are held within a chunk. For performance reasons the chunk utilizes a flattened 3d array, but helper methods <code>ContainsIndex()</code> and <code>FlattenIndex()</code> are provided.</p>

<pre><code class="language-csharp">// Chunk.cs
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Chunk {
    public static readonly Vector3Int Dimensions = new Vector3Int(32, 128, 32);

    public Vector3Int Position { get; }

    private Block[] blocks { get; }

    public Chunk(Vector3Int position) {
        Position = position;
        blocks = new Block[Dimensions.x * Dimensions.y * Dimensions.z];
    }

    public void SetBlock(Vector3Int index, Block block) {
        if (!ContainsIndex(index)) {
            throw new IndexOutOfRangeException($&quot;Chunk does not contain index: {index}&quot;);
        }

        blocks[FlattenIndex(index)] = block;
    }

    public Block GetBlock(Vector3Int index) {
        if (!ContainsIndex(index)) {
            return Block.Air();
        }

        return blocks[FlattenIndex(index)];
    }

    private bool ContainsIndex(Vector3Int index) =&gt;
        index.x &gt;= 0 &amp;&amp; index.x &lt; Dimensions.x &amp;&amp;
        index.y &gt;= 0 &amp;&amp; index.y &lt; Dimensions.y &amp;&amp;
        index.z &gt;= 0 &amp;&amp; index.z &lt; Dimensions.z;

    private int FlattenIndex(Vector3Int index) =&gt;
        (index.z * Dimensions.x * Dimensions.y) +
        (index.y * Dimensions.x) +
        index.x;
}
</code></pre>

<p>A <code>MeshData</code> class has been created to ease passing vertices, triangles, and colors around.</p>

<pre><code class="language-csharp">// MeshData.cs
using System.Collections.Generic;
using UnityEngine;

public class MeshData {
    public Vector3[] Vertices { get; }
    public int[] Triangles { get; }
    public Color32[] Colors { get; }

    public MeshData(Vector3[] vertices, int[] triangles, Color32[] colors) {
        Vertices = vertices;
        Triangles = triangles;
        Colors = colors;
    }
}
</code></pre>

<p>And lastly, a helper class for building meshes.</p>

<pre><code class="language-csharp">// MeshBuilder.cs
using System;
using System.Collections.Generic;
using UnityEngine;

public class MeshBuilder {
    private readonly List&lt;Vector3&gt; vertices;
    private readonly List&lt;int&gt; triangles;
    private readonly List&lt;Color32&gt; colors;

    public MeshBuilder() {
        vertices = new List&lt;Vector3&gt;();
        triangles = new List&lt;int&gt;();
        colors = new List&lt;Color32&gt;();
    }

    public void AddSquareFace(Vector3[] vertices, Color32 color, bool isBackFace) {
        if (vertices.Length != 4) {
            throw new ArgumentException(&quot;A square face requires 4 vertices&quot;);
        }

        // Add the 4 vertices, and color for each vertex.
        for (int i = 0; i &lt; vertices.Length; i++) {
            this.vertices.Add(vertices[i]);
            colors.Add(color);
        }

        if (!isBackFace) {
            triangles.Add(this.vertices.Count - 4);
            triangles.Add(this.vertices.Count - 3);
            triangles.Add(this.vertices.Count - 2);

            triangles.Add(this.vertices.Count - 4);
            triangles.Add(this.vertices.Count - 2);
            triangles.Add(this.vertices.Count - 1);
        } else {
            triangles.Add(this.vertices.Count - 2);
            triangles.Add(this.vertices.Count - 3);
            triangles.Add(this.vertices.Count - 4);

            triangles.Add(this.vertices.Count - 1);
            triangles.Add(this.vertices.Count - 2);
            triangles.Add(this.vertices.Count - 4);
        }
    }

    public MeshData ToMeshData() {
        MeshData data = new MeshData(
            vertices.ToArray(),
            triangles.ToArray(),
            colors.ToArray()
        );

        vertices.Clear();
        triangles.Clear();
        colors.Clear();

        return data;
    }
}
</code></pre>

<p>Let&rsquo;s go ahead and define a <code>GenerateMesh()</code> method on our <code>Chunk</code>.</p>

<pre><code class="language-csharp">// Chunk.cs

public class Chunk {
    public MeshData GenerateMesh() {

    }
}
</code></pre>

<p>Within <code>GenerateMesh()</code> well want to add a loop that runs through all 6 faces of the blocks. We&rsquo;ll also want to know if the current face is a &ldquo;back&rdquo; face.</p>

<pre><code class="language-c#">    // Iterate over each face of the blocks.
    for (int face = 0; face &lt; 6; face++) {
        bool isBackFace = face &gt; 2;
    }
</code></pre>

<p>To simplify things, we&rsquo;ll break down the problem into building slices of the mesh on 1 plane
at a time. Lets add some work variables for tracking which two axes we are working on. We will work
on the planes YZ, ZX, XY. Each plane will be visited twice, once to do the front faces, then
again to do the back faces.</p>

<pre><code class="language-c#">    int direction, workAxis1, workAxis2;

    for (int face = 0; face &lt; 6; face++) {
        bool isBackFace = face &gt; 2;
        direction = face % 3;
        workAxis1 = (direction + 1) % 3;
        workAxis2 = (direction + 2) % 3;
    }
</code></pre>

<p>We still need a few more work variables. Go ahead and add the following above the for loop.</p>

<pre><code class="language-c#">    MeshBuilder builder = new MeshBuilder();

    bool[,] merged;

    Vector3Int startPos, currPos, quadSize, m, n, offsetPos;
    Vector3[] vertices;

    Block startBlock;
</code></pre>

<p>Now add an inner for loop as seen below. This will work it&rsquo;s way through the chunk 1 layer at a time.</p>

<pre><code class="language-c#">    for (int face = 0; face &lt; 6; face++) {
        bool isBackFace = face &gt; 2;
        direction = face % 3;
        workAxis1 = (direction + 1) % 3;
        workAxis2 = (direction + 2) % 3;

        startPos = new Vector3Int();
        currPos = new Vector3Int();

        // Iterate over the chunk layer by layer.
        for (startPos[direction] = 0; startPos[direction] &lt; Dimensions[direction]; startPos[direction]++) {

        }
    }
</code></pre>

<p>We&rsquo;ll want to prep our bool array now. Since we want to be able to handle non cubic chunks we can&rsquo;t initialize it until we know which axis we are slicing. The next step is to begin building the mesh slices.</p>

<p>Start by getting the block at the current position and check to ensure that it
hasn&rsquo;t already been merged, is not an air block, and can be seen by the player. A block is considered visible to the player if the adjacent block to it is air. This will be checked via <code>IsBlockFaceVisible()</code></p>

<pre><code class="language-c#">    public bool IsBlockFaceVisible(Vector3Int blockPosition, int axis, bool backFace) {
        blockPosition[axis] += backFace ? -1 : 1;
        return !GetBlock(blockPosition).IsSolid();
    }
</code></pre>

<pre><code class="language-c#">    // Iterate over the chunk layer by layer.
    for (startPos[direction] = 0; startPos[direction] &lt; Dimensions[direction]; startPos[direction]++) {
        merged = new bool[Dimensions[workAxis1], Dimensions[workAxis2]];

        // Build the slices of the mesh.
        for (startPos[workAxis1] = 0; startPos[workAxis1] &lt; Dimensions[workAxis1]; startPos[workAxis1]++) {
            for (startPos[workAxis2] = 0; startPos[workAxis2] &lt; Dimensions[workAxis2]; startPos[workAxis2]++) {
                startBlock = GetBlock(startPos);

                // If this block has already been merged, is air, or not visible skip it.
                if (merged[startPos[workAxis1], startPos[workAxis2]] || !startBlock.IsSolid() || !IsBlockFaceVisible(startPos, direction, isBackFace)) {
                    continue;
                }
            }
        }
    }
</code></pre>

<p>Reset the quad size variable (q) back to zero. This tracks how big the current face
we are creating will be.</p>

<pre><code class="language-c#">    //Reset the work var
    quadSize = new Vector3Int();
</code></pre>

<p>Now we want to figure out how wide this face of the mesh will be. This for loop continuously
compares the next neighbor to see if it is a match to the current one.</p>

<pre><code class="language-c#">    // Figure out the width, then save it
    for (currPos = startPos, currPos[workAxis2]++; currPos[workAxis2] &lt; Dimensions[workAxis2] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis2]++) { }
    quadSize[workAxis2] = currPos[workAxis2] - startPos[workAxis2];
</code></pre>

<p>For completeness here is <code>CompareStep()</code></p>

<pre><code class="language-c#">public bool CompareStep(Vector3Int a, Vector3Int b, int direction, bool backFace) {
    Block blockA = GetBlock(a);
    Block blockB = GetBlock(b);

    return blockA == blockB &amp;&amp; blockB.IsSolid() &amp;&amp; IsBlockFaceVisible(b, direction, backFace);
}
</code></pre>

<p>Now we want to repeat the same process for the height of the face.</p>

<pre><code class="language-c#">    // Figure out the height, then save it
    for (currPos = startPos, currPos[workAxis1]++; currPos[workAxis1] &lt; Dimensions[workAxis1] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis1]++) {
        for (currPos[workAxis2] = startPos[workAxis2]; currPos[workAxis2] &lt; Dimensions[workAxis2] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis2]++) { }

        // If we didn't reach the end then its not a good add.
        if (currPos[workAxis2] - startPos[workAxis2] &lt; quadSize[workAxis2]) {
            break;
        } else {
            currPos[workAxis2] = startPos[workAxis2];
        }
    }
    quadSize[workAxis1] = currPos[workAxis1] - startPos[workAxis1];
</code></pre>

<p>Once we have figured out the height and width of the face, we can go ahead and add it to our mesh.</p>

<pre><code class="language-c#">    // Now we add the quad to the mesh
    m = new Vector3Int();
    m[workAxis1] = quadSize[workAxis1];

    n = new Vector3Int();
    n[workAxis2] = quadSize[workAxis2];

    // We need to add a slight offset when working with front faces.
    offsetPos = startPos;
    offsetPos[direction] += isBackFace ? 0 : 1;

    //Draw the face to the mesh
    vertices = new Vector3[] {
        offsetPos,
        offsetPos + m,
        offsetPos + m + n,
        offsetPos + n
    };

    builder.AddSquareFace(vertices, startBlock.GetColor(), isBackFace);
</code></pre>

<p>And lastly we need to mark all the blocks we visited as merged.</p>

<pre><code class="language-c#">    // Mark it merged
    for (int f = 0; f &lt; quadSize[workAxis1]; f++) {
        for (int g = 0; g &lt; quadSize[workAxis2]; g++) {
            merged[startPos[workAxis1] + f, startPos[workAxis2] + g] = true;
        }
    }
</code></pre>

<p>Here&rsquo;s the full algorithm for those who like to see the big picture.</p>

<pre><code class="language-c#">    public MeshData GenerateMesh() {
        MeshBuilder builder = new MeshBuilder();
        bool[,] merged;

        Vector3Int startPos, currPos, quadSize, m, n, offsetPos;
        Vector3[] vertices;

        Block startBlock;
        int direction, workAxis1, workAxis2;

        // Iterate over each face of the blocks.
        for (int face = 0; face &lt; 6; face++) {
            bool isBackFace = face &gt; 2;
            direction = face % 3;
            workAxis1 = (direction + 1) % 3;
            workAxis2 = (direction + 2) % 3;

            startPos = new Vector3Int();
            currPos = new Vector3Int();

            // Iterate over the chunk layer by layer.
            for (startPos[direction] = 0; startPos[direction] &lt; Dimensions[direction]; startPos[direction]++) {
                merged = new bool[Dimensions[workAxis1], Dimensions[workAxis2]];

                // Build the slices of the mesh.
                for (startPos[workAxis1] = 0; startPos[workAxis1] &lt; Dimensions[workAxis1]; startPos[workAxis1]++) {
                    for (startPos[workAxis2] = 0; startPos[workAxis2] &lt; Dimensions[workAxis2]; startPos[workAxis2]++) {
                        startBlock = GetBlock(startPos);

                        // If this block has already been merged, is air, or not visible skip it.
                        if (merged[startPos[workAxis1], startPos[workAxis2]] || !startBlock.IsSolid() || !IsBlockFaceVisible(startPos, direction, isBackFace)) {
                            continue;
                        }

                        // Reset the work var
                        quadSize = new Vector3Int();

                        // Figure out the width, then save it
                        for (currPos = startPos, currPos[workAxis2]++; currPos[workAxis2] &lt; Dimensions[workAxis2] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis2]++) { }
                        quadSize[workAxis2] = currPos[workAxis2] - startPos[workAxis2];

                        // Figure out the height, then save it
                        for (currPos = startPos, currPos[workAxis1]++; currPos[workAxis1] &lt; Dimensions[workAxis1] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis1]++) {
                            for (currPos[workAxis2] = startPos[workAxis2]; currPos[workAxis2] &lt; Dimensions[workAxis2] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis2]++) { }

                            // If we didn't reach the end then its not a good add.
                            if (currPos[workAxis2] - startPos[workAxis2] &lt; quadSize[workAxis2]) {
                                break;
                            } else {
                                currPos[workAxis2] = startPos[workAxis2];
                            }
                        }
                        quadSize[workAxis1] = currPos[workAxis1] - startPos[workAxis1];

                        // Now we add the quad to the mesh
                        m = new Vector3Int();
                        m[workAxis1] = quadSize[workAxis1];

                        n = new Vector3Int();
                        n[workAxis2] = quadSize[workAxis2];

                        // We need to add a slight offset when working with front faces.
                        offsetPos = startPos;
                        offsetPos[direction] += isBackFace ? 0 : 1;

                        //Draw the face to the mesh
                        vertices = new Vector3[] {
                            offsetPos,
                            offsetPos + m,
                            offsetPos + m + n,
                            offsetPos + n
                        };

                        builder.AddSquareFace(vertices, startBlock.GetColor(), isBackFace);

                        // Mark it merged
                        for (int f = 0; f &lt; quadSize[workAxis1]; f++) {
                            for (int g = 0; g &lt; quadSize[workAxis2]; g++) {
                                merged[startPos[workAxis1] + f, startPos[workAxis2] + g] = true;
                            }
                        }
                    }
                }
            }
        }

        return builder.ToMeshData();
    }
</code></pre>

<p>And last but not least, if we want to render our mesh we generated we&rsquo;ll need to pass the data to a MeshFilter. For extra bonus points we could implement an extension method to make it even cleaner.</p>

<pre><code class="language-c#">using UnityEngine;

public static class MeshFilterExts {
    public static void ApplyMeshData(this MeshFilter meshFilter, MeshData meshData) {
        meshFilter.mesh.Clear();
        meshFilter.mesh.vertices = meshData.Vertices;
        meshFilter.mesh.triangles = meshData.Triangles;

        //Color mesh and calculate normals
        meshFilter.mesh.colors32 = meshData.Colors;
        meshFilter.mesh.RecalculateNormals();
    }
}
</code></pre>

<p>Then to render our mesh we would use it like so.</p>

<pre><code class="language-c#">    MeshData mesh = chunk.GenerateMesh();

    MeshFilter meshFilter = GetComponent&lt;MeshFilter&gt;();
    meshFilter.ApplyMeshData(mesh);
</code></pre>

</section>
<div class="entry-links"></div>
</article>
<div class="share-icons-body">
  <a href="http://www.twitter.com/share?url=https%3a%2f%2feddieabbondanz.io%2fpost%2fvoxel%2fgreedy-mesh%2f" target="_blank">
  <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 612 612" style="enable-background:new 0 0 612 612;" xml:space="preserve">
  <g>
    <g>
      <path d="M437.219,245.162c0-3.088-0.056-6.148-0.195-9.18c13.214-9.848,24.675-22.171,33.744-36.275
        c-12.129,5.453-25.148,9.097-38.835,10.626c13.965-8.596,24.675-22.338,29.738-38.834c-13.075,7.928-27.54,13.603-42.924,16.552
        c-12.323-14.021-29.904-22.95-49.35-23.284c-37.332-0.612-67.598,30.934-67.598,70.463c0,5.619,0.584,11.072,1.752,16.329
        c-56.22-3.616-106.042-32.881-139.369-77c-5.814,10.571-9.152,22.922-9.152,36.164c0,25.037,11.934,47.291,30.071,60.421
        c-11.099-0.5-21.503-3.866-30.627-9.375c0,0.306,0,0.612,0,0.918c0,34.996,23.312,64.316,54.245,71.159
        c-5.675,1.613-11.656,2.448-17.804,2.421c-4.367-0.028-8.596-0.501-12.713-1.392c8.596,28.681,33.577,49.628,63.147,50.323
        c-23.145,19.194-52.298,30.655-83.955,30.572c-5.453,0-10.849-0.361-16.135-1.029c29.933,20.53,65.456,32.491,103.65,32.491
        C369.23,447.261,437.219,339.048,437.219,245.162z"/>
      <path d="M612,306C612,137.004,474.995,0,306,0C137.004,0,0,137.004,0,306c0,168.995,137.004,306,306,306
        C474.995,612,612,474.995,612,306z M27.818,306C27.818,152.36,152.36,27.818,306,27.818S584.182,152.36,584.182,306
        S459.64,584.182,306,584.182S27.818,459.64,27.818,306z"/>
    </g>
  </svg></a>
  <a href="http://plus.google.com/share?url=https%3a%2f%2feddieabbondanz.io%2fpost%2fvoxel%2fgreedy-mesh%2f" target="_blank">
  <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 612 612" style="enable-background:new 0 0 612 612;" xml:space="preserve">
    <g>
      <g>
        <path d="M349.146,402.251c0-30.016-17.387-44.815-36.525-60.922l-15.662-12.185c-4.785-3.895-11.294-9.124-11.294-18.693
          c0-9.57,6.537-15.662,12.184-21.309c18.249-14.354,36.526-29.571,36.526-61.756c0-33.076-20.892-50.462-30.878-58.724l0,0h26.956
          L358.271,153h-89.603c-23.479,0-53.049,3.478-77.863,23.924c-18.693,16.079-27.818,38.278-27.818,58.279
          c0,33.911,26.093,68.294,72.188,68.294c4.368,0,9.125-0.445,13.937-0.863c-2.17,5.23-4.34,9.569-4.34,16.97
          c0,13.464,6.955,21.753,13.047,29.57c-19.556,1.308-56.109,3.478-83.065,20.001c-25.676,15.217-33.493,37.416-33.493,53.077
          c0,32.186,30.461,62.201,93.525,62.201C309.561,484.454,349.146,443.116,349.146,402.251z M255.621,291.34
          c-37.415,0-54.384-48.292-54.384-77.418c0-11.322,2.17-23.034,9.569-32.186c6.955-8.707,19.139-14.382,30.461-14.382
          c36.108,0,54.802,48.738,54.802,80.033c0,7.845-0.862,21.754-10.877,31.768C278.237,286.11,266.498,291.312,255.621,291.34z
           M256.066,466.177c-46.54,0-76.556-22.171-76.556-53.049s27.846-41.311,37.416-44.787c18.276-6.093,41.755-6.982,45.677-6.982
          c4.34,0,6.51,0,9.987,0.445c33.076,23.479,47.402,35.218,47.402,57.416C319.992,446.176,297.821,466.177,256.066,466.177z"/>
        <polygon points="353.068,317.768 400.164,317.768 400.164,364.836 423.699,364.836 423.699,317.768 470.768,317.768 
          470.768,294.233 423.699,294.233 423.699,247.165 400.164,247.165 400.164,294.233 353.068,294.233     "/>
        <path d="M612,306C612,137.004,474.995,0,306,0C137.004,0,0,137.004,0,306c0,168.995,137.004,306,306,306
          C474.995,612,612,474.995,612,306z M27.818,306C27.818,152.36,152.36,27.818,306,27.818S584.182,152.36,584.182,306
          S459.64,584.182,306,584.182S27.818,459.64,27.818,306z"/>
      </g>
  </svg></a>
  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2feddieabbondanz.io%2fpost%2fvoxel%2fgreedy-mesh%2f" target="_blank">
  <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
     viewBox="0 0 612 612" style="enable-background:new 0 0 612 612;" xml:space="preserve">
  <g>
    <g>
      <path d="M612,306C612,137.004,474.995,0,306,0C137.004,0,0,137.004,0,306c0,168.995,137.004,306,306,306
        C474.995,612,612,474.995,612,306z M27.818,306C27.818,152.36,152.36,27.818,306,27.818S584.182,152.36,584.182,306
        S459.64,584.182,306,584.182S27.818,459.64,27.818,306z"/>
      <path d="M317.739,482.617V306h58.279l9.208-58.529h-67.487v-29.348c0-15.272,5.007-29.849,26.928-29.849h43.813v-58.418h-62.201
        c-52.298,0-66.569,34.438-66.569,82.175v35.413h-35.885V306h35.885v176.617H317.739L317.739,482.617z"/>
    </g>
  </svg>
  </a>
</div>
<div class="clearfix"></div>
<figure class="author-bio">
<img class="bio-image" src="https://eddieabbondanz.io/img/avatar.jpg" />
<figcaption class="bio-text">My name&#39;s Eddie Abbondanzio, and I&#39;m a full time Software Developer. Programming is my favorite hobby, and I love working on anything web related, and my own personal projects. If I&#39;m not programming, then I&#39;m likely working on one of my cars.</figcaption>
</figure>
<hr>

</section>
<div class="clear"></div>
</div>
<footer id="footer" style="color: #7A7B7C; background-color: #141414;background-repeat: repeat, no-repeat; background-position: left top, left top; background-size: 100px 100px, 100% 100%;">
  <div id="footer-container">
    <div class="clearfix"></div>
  </div>
  <div id="copyright">&copy; 2019. All rights reserved.</div>

</footer>
<script src="https://eddieabbondanz.io/js/highlight.pack.js"></script>
<script>
  hljs.initHighlightingOnLoad();
</script>

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date(); a = s.createElement(o),
      m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
  })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-128571017-1', 'auto');
  ga('send', 'pageview');
</script>

</div>
</body>
<link rel="shortcut icon" href="https://eddieabbondanz.io/img/favicon.ico" />
<link rel="apple-touch-icon" href="https://eddieabbondanz.io/img/apple-touch-icon.jpg" />

</html>