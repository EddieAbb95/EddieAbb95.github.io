<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta name="description" content="">
    <meta name="keywords" content="">
    <meta name="author" content="">
    <meta name="generator" content="Hugo 0.37" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://EddieAbbondanzio.github.io/css/style.css" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type="text/css">
    <link rel="alternate" href="https://EddieAbbondanzio.github.io/index.xml" type="application/rss+xml" title="Eddie Abbondanzio">

    <title>
        
        No Mans Blocks - 4/20/18  - Eddie Abbondanzio 
    </title>
</head>
    
<body>
    <header>
        <div class="container clearfix">
        
        <a class="path" href="https://EddieAbbondanzio.github.io/">Home</a>

        
        <div class="right">
            
            
            
            
            
            <a class="path" href="/page/about/">About Me</a>
        </div>
      </div>
    </header>

<div class="container">


<main role="main" class="article">
  
<article class="single" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2018-04-20">April 20, 2018</time></span>


    <span class="key">in</span>
    <span class="val">

        <a href="https://EddieAbbondanzio.github.io/categories/nomansblocks">NoMansBlocks</a>

    </span>


  </div>
  <h1 class="headline" itemprop="headline">No Mans Blocks - 4/20/18</h1>
  <section class="body" itemprop="articleBody" >
    

<h2 id="playing-around-at-the-bit-level">Playing Around at the Bit Level</h2>

<p>This weeks adventure has been exploring object serialization. Initially I was using the serializable attribute to convert my objects into byte arrays but for some objects such as the voxel chunks this is far from ideal. Since I don&rsquo;t want to handle serialization with 2 different methods I&rsquo;ve decided to bite the bullet and roll my own set up.</p>

<p>To help prepare for this task I&rsquo;ve created a BitManipulator class that allows for individual bits to be written to in a byte array. This was done to allow for writing bools as single bits vew an entire byte. The BitManipulator will be used by the ByteBuffer to help pack data as tight as possible for network traversal.</p>

<p>To limit the use of the bit manipulator it only allows for writing between 1 to 8 bits at a time. Any more than that would be unreasonable since it would be no different than writing bytes. Also by setting the upper limit to 8 it only requires us to handle 2 cases. The first when modifying only 1 byte, and the second where two (adjacent) bytes are being modified.</p>

<p>Reading bits is fairly simple.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">byte</span> ReadBits(<span style="color:#66d9ef">byte</span><span style="color:#a6e22e">[]</span> bytes, <span style="color:#66d9ef">int</span> bitIndex, <span style="color:#66d9ef">int</span> bitCount) {
    <span style="color:#75715e">//Ensure valid use of the method.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (bitCount &lt; <span style="color:#ae81ff">1</span> || bitCount &gt; <span style="color:#ae81ff">8</span>) {
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException(<span style="color:#e6db74">&#34;Bit count should be within the range of 1 to 8!&#34;</span>);
    }

    <span style="color:#75715e">//Figure out byte index, and where to start in the byte
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> byteIndex = bitIndex / <span style="color:#ae81ff">8</span>;
    <span style="color:#66d9ef">int</span> bitOffset = bitIndex % <span style="color:#ae81ff">8</span>;

    <span style="color:#75715e">//Reading from 1 byte
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (bitCount + bitOffset &lt;= <span style="color:#ae81ff">8</span>) {
        <span style="color:#75715e">//Build the mask
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">byte</span> mask = (<span style="color:#66d9ef">byte</span>)(((<span style="color:#ae81ff">1</span> &lt;&lt; bitCount) - <span style="color:#ae81ff">1</span>) &lt;&lt; bitOffset);

        <span style="color:#75715e">//Get the bits and shift them to proper location.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">byte</span>)((bytes<span style="color:#a6e22e">[byteIndex]</span> &amp; mask) &gt;&gt; bitOffset);
    }
    <span style="color:#75715e">//Reading from 2 bytes
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">//Gets the two bytes combined
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">value</span> = <span style="color:#a6e22e">SerializeUtils</span>.GetShort(bytes, byteIndex);

        <span style="color:#75715e">//Then we can pull out the data we want.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">short</span> mask = (<span style="color:#66d9ef">short</span>)(((<span style="color:#ae81ff">1</span> &lt;&lt; bitCount) - <span style="color:#ae81ff">1</span>) &lt;&lt; bitOffset);
        <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">byte</span>)((<span style="color:#66d9ef">value</span> &amp; mask) &gt;&gt; bitOffset);
    }
}</code></pre></div>
<p>Writing bits is only a little more challenging.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> WriteBits(<span style="color:#66d9ef">byte</span><span style="color:#a6e22e">[]</span> bytes, <span style="color:#66d9ef">int</span> bitIndex, <span style="color:#66d9ef">int</span> bitCount, <span style="color:#66d9ef">byte</span> <span style="color:#66d9ef">value</span>) {
    <span style="color:#75715e">//Ensure valid use of the method.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (bitCount &lt; <span style="color:#ae81ff">1</span> || bitCount &gt; <span style="color:#ae81ff">8</span>) {
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException(<span style="color:#e6db74">&#34;Bit count should be within the range of 1 to 8!&#34;</span>);
    }

    <span style="color:#75715e">//Divide it by 8, and find bit offset.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> byteIndex = bitIndex / <span style="color:#ae81ff">8</span>;
    <span style="color:#66d9ef">int</span> bitOffset = bitIndex % <span style="color:#ae81ff">8</span>;

    <span style="color:#75715e">//Writing into 1 byte case
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (bitCount + bitOffset &lt;= <span style="color:#ae81ff">8</span>) {
        <span style="color:#75715e">//shift to account for offset
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">value</span> &lt;&lt;= bitOffset;

        <span style="color:#75715e">//Build the mask
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">byte</span> mask = (<span style="color:#66d9ef">byte</span>)(((<span style="color:#ae81ff">1</span> &lt;&lt; bitCount) - <span style="color:#ae81ff">1</span>) &lt;&lt; bitOffset);

        bytes<span style="color:#a6e22e">[byteIndex]</span> &amp;= (<span style="color:#66d9ef">byte</span>)~mask;
        bytes<span style="color:#a6e22e">[byteIndex]</span> |= <span style="color:#66d9ef">value</span>;
    }
    <span style="color:#75715e">//Writing into 2 bytes case
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">//Build a short
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">short</span> splitVal = (<span style="color:#66d9ef">short</span>)(<span style="color:#66d9ef">value</span> &lt;&lt; bitOffset);
        <span style="color:#66d9ef">short</span> mask = (<span style="color:#66d9ef">short</span>)(((<span style="color:#ae81ff">1</span> &lt;&lt; bitCount) - <span style="color:#ae81ff">1</span>) &lt;&lt; bitOffset);

        <span style="color:#75715e">//Wipe the bits
</span><span style="color:#75715e"></span>        bytes<span style="color:#a6e22e">[byteIndex]</span> &amp;= (<span style="color:#66d9ef">byte</span>)~mask;
        bytes<span style="color:#a6e22e">[byteIndex]</span> |= (<span style="color:#66d9ef">byte</span>)splitVal;

        <span style="color:#75715e">//Write the bits
</span><span style="color:#75715e"></span>        bytes<span style="color:#a6e22e">[byteIndex + 1]</span> &amp;= (<span style="color:#66d9ef">byte</span>)~(mask &gt;&gt; <span style="color:#ae81ff">8</span>);
        bytes<span style="color:#a6e22e">[byteIndex + 1]</span> |= (<span style="color:#66d9ef">byte</span>)(splitVal &gt;&gt; <span style="color:#ae81ff">8</span>);
    }
}</code></pre></div>
<p>I played around with using a short pointer for writing bits but it didn&rsquo;t seem worth it to require the unsafe compile flag for a single method. It was still a fun task though. I&rsquo;ve also learned about the joys of Unit Testing and have started using it for validating all my serialization methods. Once details are a little more concrete regarding the ByteBuffer set up I&rsquo;ll provide a detailed write up on it.</p>

  </section>
</article>

</main>


</div>

<footer style="position: relative; bottom: 0px; width: 100%;">
  <div class="container">
    <span class="copyright">&copy; 2018  Eddie Abbondanzio - <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
  </div>
</footer>

</body>
</html>

